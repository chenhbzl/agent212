require 'agent212'

describe Agent212::Parser do

  context 'when parsing tokens' do
    it 'parses valid tokens' do
      Agent212::Parser.new('foo').parse_token.should == 'foo'
      Agent212::Parser.new('BaR').parse_token.should == 'BaR'
      Agent212::Parser.new('23489.quux').parse_token.should == '23489.quux'
      Agent212::Parser.new('URL%20encoded').parse_token.should == 'URL%20encoded'
    end

    it 'does not parse invalid tokens' do
      Agent212::Parser.new('(foo)').parse_token.should be_nil
      Agent212::Parser.new('\tBaR').parse_token.should be_nil
    end
  end


  context "when parsing LWS" do
    it 'recognizes a space character as whitespace' do
      x = Agent212::Parser.new("foo foo")
      x.parse_token
      x.parse_lws.should == ' '
    end

    it 'recognizes a tab character as whitespace' do
      x = Agent212::Parser.new("foo\tfoo")
      x.parse_token
      x.parse_lws.should == "\t"
    end

    it 'does not match non-whitespace characters' do
      Agent212::Parser.new('foo').parse_lws.should be_nil
      Agent212::Parser.new('bar ').parse_lws.should be_nil
    end
  end


  context "when parsing a whole user_agent string" do
    VIADEO_CLIENT_UA = "Viadeo%20Sync%20for%20the%20Mac/0.1.2 CFNetwork/520.4.3 Darwin/11.4.0 (x86_64) (MacBook6%2C1)"
    IPAD_UA = "Mozilla/5.0 (iPad; U; CPU OS 3_2_1 like Mac OS X; en-us) AppleWebKit/531.21.10 (KHTML, like Gecko) Mobile/7B405"

    it "detects all comments" do
      ua = Agent212::UserAgent.parse(VIADEO_CLIENT_UA)
      ua.should_not be_nil
      ua.comments.size.should == 2
      ua.comments.should include("(x86_64)")
    end

    it "detects the Webkit-product" do
      ua = Agent212::UserAgent.parse(IPAD_UA)
      ua.products.detect { |product| product.name == "AppleWebKit" }.should_not be_nil
    end
  end


  context 'when parsing nil' do
    it "returns an empty UserAgent object" do
      ua = Agent212::UserAgent.parse(nil)
      ua.should be_empty
    end
  end


  context "when parsing a list of real life http-user-agent strings" do

    # The following test proves that most user agent strings that you can observe in the wild will conform to the RFC. This is sometimes disputed by people who did not actually test their claim.
    # Most of these UA strings were collected by Soocial (soocial.com has since closed down); hence many of these come from different mobile phones. Many of those actually generated by Soocial's own client software. This of course skews the test results. Feel free to adapt the test data to your needs.

    # TODO: find or make a new list of only browsers
    # TODO: make a new list without Soocial clients

    def can_parse_ua_string?(user_agent_string)
      ua = Agent212::UserAgent.parse user_agent_string
      return true
    rescue Agent212::Error => error
      puts "    * #{error} in:\n      #{user_agent_string.inspect}"
      return false
    end

    def parsing_succes_counts(filename)
      total = 0
      successes = 0
      File.open(filename, 'r') do |file|
        file.each_line do |line|
          next if line.empty?
          next if line.start_with?('#')
          successes += 1 if can_parse_ua_string?(line)
          total += 1
        end
      end
      [successes, total]
    end

    def failure_rate(successes, total)
      failures = total - successes
      failures.to_f / total.to_f
    end

    it "succesfully parses *most* lines (less than 0.1% may fail)" do
      (successes, total) = parsing_succes_counts("#{File.dirname(__FILE__)}/http_user_agents.txt")
      failure_rate(successes, total).should < 0.001
    end

    it "succesfully parses *most* lines from useragentswitcher.xml (> 99%)" do
      # There are three failures over 500-something UA strings. That makes the
      # failure rate just above 0.05. In two cases closing brackets are
      # missing from two Linux browser UA strings. Is this really the case or
      # could it be an error in the useragentswitcher file?

      successes = 0
      total = 0
      Dir.glob("#{File.dirname(__FILE__)}/data/**/ua_strings.txt") do |filename|
        (s, t) = parsing_succes_counts(filename)
        successes += s
        total += t
      end
      # puts "scanned #{total} lines, #{successes} succesful"
      failure_rate(successes, total).should < 0.01
    end
  end
end
